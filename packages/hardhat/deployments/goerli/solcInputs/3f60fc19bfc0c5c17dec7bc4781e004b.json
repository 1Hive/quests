{
  "language": "Solidity",
  "sources": {
    "contracts/mocks/OwnableCelesteMock.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2022-01-07\n */\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/token/ERC20.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract GovernERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value) public returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// File: contracts/arbitration/IArbitrator.sol\n\npragma solidity ^0.5.8;\n\ninterface IArbitrator {\n    /**\n     * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n     * @param _possibleRulings Number of possible rulings allowed for the dispute\n     * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n     * @return Dispute identification number\n     */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata)\n        external\n        returns (uint256);\n\n    /**\n     * @dev Submit evidence for a dispute\n     * @param _disputeId Id of the dispute in the Protocol\n     * @param _submitter Address of the account submitting the evidence\n     * @param _evidence Data submitted for the evidence related to the dispute\n     */\n    function submitEvidence(\n        uint256 _disputeId,\n        address _submitter,\n        bytes calldata _evidence\n    ) external;\n\n    /**\n     * @dev Close the evidence period of a dispute\n     * @param _disputeId Identification number of the dispute to close its evidence submitting period\n     */\n    function closeEvidencePeriod(uint256 _disputeId) external;\n\n    /**\n     * @notice Rule dispute #`_disputeId` if ready\n     * @param _disputeId Identification number of the dispute to be ruled\n     * @return subject Arbitrable instance associated to the dispute\n     * @return ruling Ruling number computed for the given dispute\n     */\n    function rule(uint256 _disputeId)\n        external\n        returns (address subject, uint256 ruling);\n\n    /**\n     * @dev Tell the dispute fees information to create a dispute\n     * @return recipient Address where the corresponding dispute fees must be transferred to\n     * @return feeToken ERC20 token used for the fees\n     * @return feeAmount Total amount of fees that must be allowed to the recipient\n     */\n    function getDisputeFees()\n        external\n        view\n        returns (\n            address recipient,\n            GovernERC20 feeToken,\n            uint256 feeAmount\n        );\n}\n\n// File: contracts/lib/os/SafeERC20.sol\n\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\n// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n\npragma solidity ^0.5.8;\n\nlibrary SafeGovernERC20 {\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    /**\n     * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n     *      Note that this makes an external call to the token.\n     */\n    function safeTransfer(\n        GovernERC20 _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferCallData);\n    }\n\n    /**\n     * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n     *      Note that this makes an external call to the token.\n     */\n    function safeTransferFrom(\n        GovernERC20 _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\n    }\n\n    /**\n     * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n     *      Note that this makes an external call to the token.\n     */\n    function safeApprove(\n        GovernERC20 _token,\n        address _spender,\n        uint256 _amount\n    ) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), approveCallData);\n    }\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40) // free memory pointer\n\n            let success := call(\n                gas, // forward all gas\n                _addr, // address\n                0, // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata), // calldata length\n                ptr, // write output over free memory\n                0x20 // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n                // Not sure what was returned: don't mark as success\n                default {\n\n                }\n            }\n        }\n        return ret;\n    }\n}\n\n// File: contracts/ownable-celeste/OwnableCeleste.sol\n\npragma solidity ^0.5.8;\n\ncontract OwnableCeleste is IArbitrator {\n    using SafeGovernERC20 for GovernERC20;\n\n    // Note that Aragon Court treats the possible outcomes as arbitrary numbers, leaving the Arbitrable (us) to define how to understand them.\n    // Some outcomes [0, 1, and 2] are reserved by Aragon Court: \"missing\", \"leaked\", and \"refused\", respectively.\n    // This Arbitrable introduces the concept of the challenger/submitter (a binary outcome) as 3/4.\n    // Note that Aragon Court emits the lowest outcome in the event of a tie, and so for us, we prefer the challenger.\n    uint256 private constant DISPUTES_NOT_RULED = 0;\n    uint256 private constant DISPUTES_RULING_CHALLENGER = 3;\n    uint256 private constant DISPUTES_RULING_SUBMITTER = 4;\n    address private disputeManager;\n\n    enum State {\n        NOT_DISPUTED,\n        DISPUTED,\n        DISPUTES_NOT_RULED,\n        DISPUTES_RULING_CHALLENGER,\n        DISPUTES_RULING_SUBMITTER\n    }\n\n    struct Dispute {\n        address subject;\n        State state;\n    }\n\n    GovernERC20 public feeToken;\n    uint256 public feeAmount;\n    uint256 public currentId;\n    address public owner;\n    mapping(uint256 => Dispute) public disputes;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ERR:NOT_OWNER\");\n        _;\n    }\n\n    constructor(GovernERC20 _feeToken, uint256 _feeAmount) public {\n        owner = msg.sender;\n        feeToken = _feeToken;\n        feeAmount = _feeAmount;\n        disputeManager = address(new DisputeManager(address(this)));\n    }\n\n    function getDisputeManager() external view returns (address) {\n        return disputeManager;\n    }\n\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    /**\n     * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n     * @param _possibleRulings Number of possible rulings allowed for the dispute\n     * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n     * @return Dispute identification number\n     */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata)\n        external\n        returns (uint256)\n    {\n        uint256 disputeId = currentId;\n        disputes[disputeId] = Dispute(msg.sender, State.DISPUTED);\n        currentId++;\n\n        require(\n            feeToken.safeTransferFrom(msg.sender, address(this), feeAmount),\n            \"ERR:DEPOSIT_FAILED\"\n        );\n        return disputeId;\n    }\n\n    function decideDispute(uint256 _disputeId, State _state)\n        external\n        onlyOwner\n    {\n        require(\n            _state != State.NOT_DISPUTED && _state != State.DISPUTED,\n            \"ERR:OUTCOME_NOT_ASSIGNABLE\"\n        );\n\n        Dispute storage dispute = disputes[_disputeId];\n        require(dispute.state == State.DISPUTED, \"ERR:NOT_DISPUTED\");\n\n        dispute.state = _state;\n    }\n\n    /**\n     * @dev Submit evidence for a dispute\n     * @param _disputeId Id of the dispute in the Protocol\n     * @param _submitter Address of the account submitting the evidence\n     * @param _evidence Data submitted for the evidence related to the dispute\n     */\n    function submitEvidence(\n        uint256 _disputeId,\n        address _submitter,\n        bytes calldata _evidence\n    ) external {}\n\n    /**\n     * @dev Close the evidence period of a dispute\n     * @param _disputeId Identification number of the dispute to close its evidence submitting period\n     */\n    function closeEvidencePeriod(uint256 _disputeId) external {}\n\n    /**\n     * @notice Rule dispute #`_disputeId` if ready\n     * @param _disputeId Identification number of the dispute to be ruled\n     * @return subject Arbitrable instance associated to the dispute\n     * @return ruling Ruling number computed for the given dispute\n     */\n    function rule(uint256 _disputeId)\n        external\n        returns (address subject, uint256 ruling)\n    {\n        Dispute storage dispute = disputes[_disputeId];\n\n        if (dispute.state == State.DISPUTES_RULING_CHALLENGER) {\n            return (dispute.subject, DISPUTES_RULING_CHALLENGER);\n        } else if (dispute.state == State.DISPUTES_RULING_SUBMITTER) {\n            return (dispute.subject, DISPUTES_RULING_SUBMITTER);\n        } else if (dispute.state == State.DISPUTES_NOT_RULED) {\n            return (dispute.subject, DISPUTES_NOT_RULED);\n        } else {\n            revert();\n        }\n    }\n\n    /**\n     * @dev Tell the dispute fees information to create a dispute\n     * @return recipient Address where the corresponding dispute fees must be transferred to\n     * @return feeToken ERC20 token used for the fees\n     * @return feeAmount Total amount of fees that must be allowed to the recipient\n     */\n    function getDisputeFees()\n        external\n        view\n        returns (\n            address,\n            GovernERC20,\n            uint256\n        )\n    {\n        return (address(this), feeToken, feeAmount);\n    }\n}\n\ncontract DisputeManager {\n    using SafeGovernERC20 for GovernERC20;\n\n    OwnableCeleste celeste;\n\n    constructor(address mockCelesteAddress) public {\n        celeste = OwnableCeleste(mockCelesteAddress);\n    }\n\n    function getDisputeFees() external view returns (GovernERC20, uint256) {\n        (address celeste, GovernERC20 feeToken, uint256 feeAmount) = celeste\n            .getDisputeFees();\n        return (feeToken, feeAmount);\n    }\n\n    function getDispute(uint256 _disputeId)\n        external\n        view\n        returns (\n            address subject,\n            uint8 possibleRulings,\n            OwnableCeleste.State state,\n            uint8 finalRuling,\n            uint256 lastRoundId,\n            uint64 createTermId\n        )\n    {\n        (address subject, OwnableCeleste.State state) = celeste.disputes(\n            _disputeId\n        );\n        return (subject, 0, state, 0, 0, 0);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}